{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nexport function useWebSocket(url, {\n  manual = false\n} = {}) {\n  _s();\n  const socketRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectInterval = useRef(1000);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const messageQueue = useRef([]);\n  const getWebSocketUrl = useCallback(() => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        setError('Authentication token not found');\n        return null;\n      }\n      const wsUrl = new URL(url);\n      wsUrl.searchParams.set('token', token);\n      return wsUrl.toString();\n    } catch (e) {\n      console.error('Invalid WebSocket URL:', e);\n      setError('Invalid WebSocket URL');\n      return null;\n    }\n  }, [url]);\n  const handleIncomingMessage = useCallback(data => {\n    switch (data.type) {\n      case 'MESSAGE':\n        setMessages(prev => [...prev, data.data]);\n        break;\n      case 'HISTORY':\n        setMessages(data.data);\n        break;\n      case 'AUTH_ERROR':\n        setError(`Authentication error: ${data.message}`);\n        localStorage.removeItem('token');\n        window.location.reload();\n        break;\n      default:\n        console.warn('Unhandled message type:', data.type);\n    }\n  }, []);\n  const processMessageQueue = () => {\n    while (messageQueue.current.length > 0 && ((_socketRef$current = socketRef.current) === null || _socketRef$current === void 0 ? void 0 : _socketRef$current.readyState) === WebSocket.OPEN) {\n      var _socketRef$current;\n      const message = messageQueue.current.shift();\n      socketRef.current.send(JSON.stringify(message));\n    }\n  };\n\n  // 2. Обновленный useWebSocket.js (React)\n  const connect = useCallback(() => {\n    const wsUrl = getWebSocketUrl();\n    if (!wsUrl) return;\n    if (socketRef.current) {\n      if (socketRef.current.readyState === WebSocket.OPEN) {\n        console.log('Already connected');\n        return;\n      }\n      socketRef.current.close();\n    }\n    console.log('Attempting WebSocket connection...');\n    setConnectionStatus('connecting');\n    const ws = new WebSocket(wsUrl);\n    socketRef.current = ws;\n    ws.onopen = () => {\n      console.log('WebSocket connected');\n      setIsConnected(true);\n      setConnectionStatus('connected');\n      setError(null);\n      reconnectInterval.current = 1000;\n      processMessageQueue();\n\n      // Запрос истории\n      const historyRequest = JSON.stringify({\n        type: 'GET_HISTORY',\n        timestamp: Date.now()\n      });\n      ws.send(historyRequest);\n    };\n    ws.onmessage = event => {\n      try {\n        const parsedData = JSON.parse(event.data);\n        handleIncomingMessage(parsedData);\n      } catch (e) {\n        console.error('Message parse error:', e);\n      }\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n      setError('Connection error');\n      setConnectionStatus('error');\n    };\n    ws.onclose = event => {\n      console.log(`WebSocket closed: ${event.code}`, event.reason);\n      setIsConnected(false);\n      setConnectionStatus('disconnected');\n      if (event.code === 4002) {\n        // Аутентификация\n        handleIncomingMessage({\n          type: 'AUTH_ERROR',\n          message: event.reason || 'Authentication failed'\n        });\n        return;\n      }\n      if (!event.wasClean && event.code !== 1000) {\n        const timeout = Math.min(reconnectInterval.current * 2, 30000);\n        reconnectInterval.current = timeout;\n        console.log(`Reconnecting in ${timeout}ms...`);\n        reconnectTimeoutRef.current = setTimeout(connect, timeout);\n      }\n    };\n  }, [getWebSocketUrl, handleIncomingMessage]);\n  const disconnect = useCallback((permanent = false) => {\n    if (socketRef.current) {\n      if (permanent) {\n        socketRef.current.onclose = null;\n      }\n      socketRef.current.close(permanent ? 1000 : 1001, permanent ? 'Normal closure' : 'Reconnecting');\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _socketRef$current2;\n    const userId = parseInt(localStorage.getItem('userId'), 10);\n    if (isNaN(userId)) {\n      setError('Invalid user ID');\n      return;\n    }\n    const fullMessage = {\n      ...message,\n      timestamp: Date.now(),\n      userId,\n      username: localStorage.getItem('username') || 'unknown'\n    };\n    if (((_socketRef$current2 = socketRef.current) === null || _socketRef$current2 === void 0 ? void 0 : _socketRef$current2.readyState) === WebSocket.OPEN) {\n      try {\n        socketRef.current.send(JSON.stringify(fullMessage));\n      } catch (e) {\n        console.error('Send error:', e);\n        setError('Failed to send message');\n      }\n    } else {\n      console.warn('Queueing message - connection not ready');\n      messageQueue.current.push(fullMessage);\n    }\n  }, []);\n  useEffect(() => {\n    if (!manual) {\n      connect();\n    }\n    return () => {\n      disconnect(true);\n      messageQueue.current = [];\n    };\n  }, [connect, disconnect, manual]);\n  return {\n    isConnected,\n    connectionStatus,\n    messages,\n    sendMessage,\n    connect,\n    disconnect,\n    error\n  };\n}\n_s(useWebSocket, \"w6m2WdmUtH3IgEjQjr9T/afgwQI=\");\nexport default useWebSocket;\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     const token = localStorage.getItem('token');\n//     if (!token) {\n//       setError('Authentication token not found');\n//       return null;\n//     }\n\n//     try {\n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     if (data.type === 'AUTH_ERROR') {\n//       console.error('Authentication error:', data.message);\n//       setError(data.message);\n//       disconnect();\n//       localStorage.removeItem('token');\n//       window.location.reload();\n//       return;\n//     }\n//     setMessages(prev => [...prev, data]);\n//   }, []);\n\n//   const connect = useCallback(() => {\n//     const wsUrl = getWebSocketUrl();\n//     if (!wsUrl) return;\n\n//     if (socketRef.current && \n//       [WebSocket.OPEN, WebSocket.CONNECTING].includes(socketRef.current.readyState)) {\n//       console.warn('WebSocket already connecting or connected');\n//       return;\n//     }\n\n//     setConnectionStatus('connecting');\n//     console.log('Connecting to WebSocket...');\n\n//     socketRef.current = new WebSocket(wsUrl);\n\n//     socketRef.current.onopen = () => {\n//       console.log('WebSocket connected');\n//       setIsConnected(true);\n//       setConnectionStatus('connected');\n//       setError(null);\n//     };\n\n//     socketRef.current.onmessage = (event) => {\n//       try {\n//         const parsedData = JSON.parse(event.data);\n//         handleIncomingMessage(parsedData);\n//       } catch (e) {\n//         console.warn('Non-JSON message:', event.data);\n//         handleIncomingMessage({ content: event.data });\n//       }\n//     };\n\n//     socketRef.current.onerror = (event) => {\n//       console.error('WebSocket error:', event);\n//       setError('WebSocket connection error');\n//       setConnectionStatus('error');\n//     };\n\n//     socketRef.current.onclose = (event) => {\n//       console.log(`WebSocket closed: ${event.code} ${event.reason}`);\n//       setIsConnected(false);\n//       setConnectionStatus('disconnected');\n\n//       if (!event.wasClean && event.code !== 1000) {\n//         console.log('Reconnecting in 3 seconds...');\n//         reconnectTimeoutRef.current = setTimeout(() => {\n//           connect();\n//         }, 3000);\n//       }\n//     };\n//   }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = () => {};\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       const messageWithAuth = {\n//         ...message,\n//         timestamp: new Date().toISOString(),\n//         user_id: parseInt(localStorage.getItem('userId'), 10),\n//         username: localStorage.getItem('username') || 'unknown',\n//       };\n//       const raw = localStorage.getItem('username');\n//       console.log('Stored username:', raw); // должно быть нормальное имя\n\n//       try {\n//         socketRef.current.send(JSON.stringify(messageWithAuth));\n//       } catch (e) {\n//         console.error('Error sending message:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.error('Cannot send message - WebSocket not open');\n//       setError('Connection not ready');\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error,\n//   };\n// }\n\n// export default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useWebSocket","url","manual","_s","socketRef","reconnectTimeoutRef","reconnectInterval","isConnected","setIsConnected","connectionStatus","setConnectionStatus","messages","setMessages","error","setError","messageQueue","getWebSocketUrl","token","localStorage","getItem","wsUrl","URL","searchParams","set","toString","e","console","handleIncomingMessage","data","type","prev","message","removeItem","window","location","reload","warn","processMessageQueue","current","length","_socketRef$current","readyState","WebSocket","OPEN","shift","send","JSON","stringify","connect","log","close","ws","onopen","historyRequest","timestamp","Date","now","onmessage","event","parsedData","parse","onerror","onclose","code","reason","wasClean","timeout","Math","min","setTimeout","disconnect","permanent","clearTimeout","sendMessage","_socketRef$current2","userId","parseInt","isNaN","fullMessage","username","push"],"sources":["/Users/darinautalieva/Desktop/GOProject/forum-frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\n\nexport function useWebSocket(url, { manual = false } = {}) {\n  const socketRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectInterval = useRef(1000);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const messageQueue = useRef([]);\n\n  const getWebSocketUrl = useCallback(() => {\n    try {\n      const token = localStorage.getItem('token');\n      if (!token) {\n        setError('Authentication token not found');\n        return null;\n      }\n      \n      const wsUrl = new URL(url);\n      wsUrl.searchParams.set('token', token);\n      return wsUrl.toString();\n    } catch (e) {\n      console.error('Invalid WebSocket URL:', e);\n      setError('Invalid WebSocket URL');\n      return null;\n    }\n  }, [url]);\n\n  const handleIncomingMessage = useCallback((data) => {\n    switch (data.type) {\n      case 'MESSAGE':\n        setMessages(prev => [...prev, data.data]);\n        break;\n      case 'HISTORY':\n        setMessages(data.data);\n        break;\n      case 'AUTH_ERROR':\n        setError(`Authentication error: ${data.message}`);\n        localStorage.removeItem('token');\n        window.location.reload();\n        break;\n      default:\n        console.warn('Unhandled message type:', data.type);\n    }\n  }, []);\n\n  const processMessageQueue = () => {\n    while (messageQueue.current.length > 0 && socketRef.current?.readyState === WebSocket.OPEN) {\n      const message = messageQueue.current.shift();\n      socketRef.current.send(JSON.stringify(message));\n    }\n  };\n\n  // 2. Обновленный useWebSocket.js (React)\nconst connect = useCallback(() => {\n  const wsUrl = getWebSocketUrl();\n  if (!wsUrl) return;\n\n  if (socketRef.current) {\n    if (socketRef.current.readyState === WebSocket.OPEN) {\n      console.log('Already connected');\n      return;\n    }\n    socketRef.current.close();\n  }\n\n  console.log('Attempting WebSocket connection...');\n  setConnectionStatus('connecting');\n  \n  const ws = new WebSocket(wsUrl);\n  socketRef.current = ws;\n\n  ws.onopen = () => {\n    console.log('WebSocket connected');\n    setIsConnected(true);\n    setConnectionStatus('connected');\n    setError(null);\n    reconnectInterval.current = 1000;\n    processMessageQueue();\n    \n    // Запрос истории\n    const historyRequest = JSON.stringify({\n      type: 'GET_HISTORY',\n      timestamp: Date.now()\n    });\n    ws.send(historyRequest);\n  };\n\n  ws.onmessage = (event) => {\n    try {\n      const parsedData = JSON.parse(event.data);\n      handleIncomingMessage(parsedData);\n    } catch (e) {\n      console.error('Message parse error:', e);\n    }\n  };\n\n  ws.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    setError('Connection error');\n    setConnectionStatus('error');\n  };\n\n  ws.onclose = (event) => {\n    console.log(`WebSocket closed: ${event.code}`, event.reason);\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n\n    if (event.code === 4002) { // Аутентификация\n      handleIncomingMessage({\n        type: 'AUTH_ERROR',\n        message: event.reason || 'Authentication failed'\n      });\n      return;\n    }\n\n    if (!event.wasClean && event.code !== 1000) {\n      const timeout = Math.min(reconnectInterval.current * 2, 30000);\n      reconnectInterval.current = timeout;\n      console.log(`Reconnecting in ${timeout}ms...`);\n      reconnectTimeoutRef.current = setTimeout(connect, timeout);\n    }\n  };\n}, [getWebSocketUrl, handleIncomingMessage]);\n\n  const disconnect = useCallback((permanent = false) => {\n    if (socketRef.current) {\n      if (permanent) {\n        socketRef.current.onclose = null;\n      }\n      socketRef.current.close(\n        permanent ? 1000 : 1001,\n        permanent ? 'Normal closure' : 'Reconnecting'\n      );\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n  }, []);\n\n  const sendMessage = useCallback((message) => {\n    const userId = parseInt(localStorage.getItem('userId'), 10);\n    if (isNaN(userId)) {\n      setError('Invalid user ID');\n      return;\n    }\n    \n    const fullMessage = {\n      ...message,\n      timestamp: Date.now(),\n      userId,\n      username: localStorage.getItem('username') || 'unknown'\n    };\n\n    if (socketRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        socketRef.current.send(JSON.stringify(fullMessage));\n      } catch (e) {\n        console.error('Send error:', e);\n        setError('Failed to send message');\n      }\n    } else {\n      console.warn('Queueing message - connection not ready');\n      messageQueue.current.push(fullMessage);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!manual) {\n      connect();\n    }\n\n    return () => {\n      disconnect(true);\n      messageQueue.current = [];\n    };\n  }, [connect, disconnect, manual]);\n\n  return {\n    isConnected,\n    connectionStatus,\n    messages,\n    sendMessage,\n    connect,\n    disconnect,\n    error\n  };\n}\n\nexport default useWebSocket;\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     const token = localStorage.getItem('token');\n//     if (!token) {\n//       setError('Authentication token not found');\n//       return null;\n//     }\n\n//     try {\n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     if (data.type === 'AUTH_ERROR') {\n//       console.error('Authentication error:', data.message);\n//       setError(data.message);\n//       disconnect();\n//       localStorage.removeItem('token');\n//       window.location.reload();\n//       return;\n//     }\n//     setMessages(prev => [...prev, data]);\n//   }, []);\n\n//   const connect = useCallback(() => {\n//     const wsUrl = getWebSocketUrl();\n//     if (!wsUrl) return;\n\n//     if (socketRef.current && \n//       [WebSocket.OPEN, WebSocket.CONNECTING].includes(socketRef.current.readyState)) {\n//       console.warn('WebSocket already connecting or connected');\n//       return;\n//     }\n\n//     setConnectionStatus('connecting');\n//     console.log('Connecting to WebSocket...');\n\n//     socketRef.current = new WebSocket(wsUrl);\n\n//     socketRef.current.onopen = () => {\n//       console.log('WebSocket connected');\n//       setIsConnected(true);\n//       setConnectionStatus('connected');\n//       setError(null);\n//     };\n\n//     socketRef.current.onmessage = (event) => {\n//       try {\n//         const parsedData = JSON.parse(event.data);\n//         handleIncomingMessage(parsedData);\n//       } catch (e) {\n//         console.warn('Non-JSON message:', event.data);\n//         handleIncomingMessage({ content: event.data });\n//       }\n//     };\n\n//     socketRef.current.onerror = (event) => {\n//       console.error('WebSocket error:', event);\n//       setError('WebSocket connection error');\n//       setConnectionStatus('error');\n//     };\n\n//     socketRef.current.onclose = (event) => {\n//       console.log(`WebSocket closed: ${event.code} ${event.reason}`);\n//       setIsConnected(false);\n//       setConnectionStatus('disconnected');\n\n//       if (!event.wasClean && event.code !== 1000) {\n//         console.log('Reconnecting in 3 seconds...');\n//         reconnectTimeoutRef.current = setTimeout(() => {\n//           connect();\n//         }, 3000);\n//       }\n//     };\n//   }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = () => {};\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       const messageWithAuth = {\n//         ...message,\n//         timestamp: new Date().toISOString(),\n//         user_id: parseInt(localStorage.getItem('userId'), 10),\n//         username: localStorage.getItem('username') || 'unknown',\n//       };\n//       const raw = localStorage.getItem('username');\n//       console.log('Stored username:', raw); // должно быть нормальное имя\n      \n//       try {\n//         socketRef.current.send(JSON.stringify(messageWithAuth));\n//       } catch (e) {\n//         console.error('Error sending message:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.error('Cannot send message - WebSocket not open');\n//       setError('Connection not ready');\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error,\n//   };\n// }\n\n// export default useWebSocket;"],"mappings":"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A,CAAmBjC,UAAU,MAAKC,SAAS,CAACC,IAAI,EAAE;MACpD,IAAI;QACFvC,SAAS,CAACkC,OAAO,CAACO,IAAI,CAACC,IAAI,CAACC,SAAS,CAAC+B,WAAW,CAAC,CAAC;MACrD,CAAC,CAAC,OAAOrD,CAAC,EAAE;QACVC,OAAO,CAACb,KAAK,CAAC,aAAa,EAAEY,CAAC,CAAC;QAC/BX,QAAQ,CAAC,wBAAwB,CAAC;MACpC;IACF,CAAC,MAAM;MACLY,OAAO,CAACU,IAAI,CAAC,yCAAyC,CAAC;MACvDrB,YAAY,CAACuB,OAAO,CAAC0C,IAAI,CAACF,WAAW,CAAC;IACxC;EACF,CAAC,EAAE,EAAE,CAAC;EAENlF,SAAS,CAAC,MAAM;IACd,IAAI,CAACM,MAAM,EAAE;MACX8C,OAAO,CAAC,CAAC;IACX;IAEA,OAAO,MAAM;MACXsB,UAAU,CAAC,IAAI,CAAC;MAChBvD,YAAY,CAACuB,OAAO,GAAG,EAAE;IAC3B,CAAC;EACH,CAAC,EAAE,CAACU,OAAO,EAAEsB,UAAU,EAAEpE,MAAM,CAAC,CAAC;EAEjC,OAAO;IACLK,WAAW;IACXE,gBAAgB;IAChBE,QAAQ;IACR8D,WAAW;IACXzB,OAAO;IACPsB,UAAU;IACVzD;EACF,CAAC;AACH;AAACV,EAAA,CA3LeH,YAAY;AA6L5B,eAAeA,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}