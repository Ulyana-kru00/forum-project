{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nconst useWebSocket = (webSocketUrl, apiUrl, token) => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [status, setStatus] = useState('disconnected');\n  const [error, setError] = useState(null);\n  const ws = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const loadHistory = useCallback(async () => {\n    try {\n      const response = await fetch(apiUrl, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      const history = await response.json();\n      setMessages(history);\n    } catch (err) {\n      setError(err.message);\n      console.error('History load error:', err);\n    }\n  }, [apiUrl, token]);\n  const connectWebSocket = useCallback(() => {\n    if (!token || status === 'connected') return;\n    const wsUrl = new URL(webSocketUrl);\n    wsUrl.searchParams.set('token', token);\n    ws.current = new WebSocket(wsUrl.href);\n    setStatus('connecting');\n    ws.current.onopen = () => {\n      console.log('WebSocket connected');\n      reconnectAttempts.current = 0;\n      setStatus('connected');\n      setError(null);\n    };\n    ws.current.onmessage = event => {\n      try {\n        const newMessage = JSON.parse(event.data);\n        setMessages(prev => [...prev, newMessage]);\n      } catch (err) {\n        console.error('Message parse error:', err);\n      }\n    };\n    ws.current.onclose = event => {\n      console.log('WebSocket closed:', event.code, event.reason);\n      setStatus('disconnected');\n      if (event.code === 4001 || event.code === 4002) {\n        setError('Authentication required');\n        return;\n      }\n\n      // Exponential backoff reconnect\n      const timeout = Math.min(1000 * 2 ** reconnectAttempts.current, 30000);\n      setTimeout(() => {\n        reconnectAttempts.current++;\n        connectWebSocket();\n      }, timeout);\n    };\n    ws.current.onerror = err => {\n      console.error('WebSocket error:', err);\n      setStatus('error');\n      setError('Connection error');\n    };\n  }, [webSocketUrl, token, status]);\n  useEffect(() => {\n    if (!token) {\n      setError('Authentication token is required');\n      return;\n    }\n    loadHistory();\n    connectWebSocket();\n    return () => {\n      var _ws$current;\n      if (((_ws$current = ws.current) === null || _ws$current === void 0 ? void 0 : _ws$current.readyState) === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [token, loadHistory, connectWebSocket]);\n  const sendMessage = useCallback(message => {\n    var _ws$current2;\n    if (((_ws$current2 = ws.current) === null || _ws$current2 === void 0 ? void 0 : _ws$current2.readyState) === WebSocket.OPEN) {\n      ws.current.send(JSON.stringify({\n        ...message,\n        timestamp: new Date().toISOString()\n      }));\n    }\n  }, []);\n  return {\n    messages,\n    sendMessage,\n    status,\n    error,\n    retry: loadHistory\n  };\n};\n_s(useWebSocket, \"N+BZmd1lI7q8wuiZgXoe7+Gw++8=\");\nexport default useWebSocket;\n// // useWebSocket.js\n// import { useState, useEffect } from 'react';\n// const useWebSocket = (url) => {\n//     const [socket, setSocket] = useState(null);\n//     const [messages, setMessages] = useState([]);\n//     const [connectionStatus, setConnectionStatus] = useState('disconnected');\n\n//     useEffect(() => {\n//         const ws = new WebSocket(url);\n\n//         ws.onopen = () => {\n//             console.log('WebSocket connected');\n//             setSocket(ws);\n//             setConnectionStatus('connected');\n//         };\n\n//         ws.onmessage = (event) => {\n//             try {\n//                 const newMessage = JSON.parse(event.data);\n//                 setMessages(prev => [...prev, newMessage]);\n//             } catch (err) {\n//                 console.error('Error parsing WebSocket message:', err);\n//             }\n//         };\n\n//         ws.onclose = () => {\n//             console.log('WebSocket disconnected');\n//             setSocket(null);\n//             setConnectionStatus('disconnected');\n//             // Attempt to reconnect after 5 seconds\n//             setTimeout(() => {\n//                 setConnectionStatus('reconnecting');\n//             }, 5000);\n//         };\n\n//         ws.onerror = (error) => {\n//             console.error('WebSocket error:', error);\n//             setConnectionStatus('error');\n//         };\n\n//         return () => {\n//             if (ws && ws.readyState === WebSocket.OPEN) {\n//                 ws.close();\n//             }\n//         };\n//     }, [url]);\n\n//     const sendMessage = (message) => {\n//         if (socket && socket.readyState === WebSocket.OPEN) {\n//             socket.send(JSON.stringify(message));\n//         } else {\n//             console.error('WebSocket is not connected');\n//             // Optionally queue messages when disconnected\n//         }\n//     };\n\n//     return { \n//         socket, \n//         messages, \n//         sendMessage, \n//         connectionStatus \n//     };\n// };\n\n// export default useWebSocket; // Добавьте эту строку\n\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const reconnectInterval = useRef(1000);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n//   const messageQueue = useRef([]);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     try {\n//       const token = localStorage.getItem('token');\n//       if (!token) {\n//         setError('Authentication token not found');\n//         return null;\n//       }\n\n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     switch (data.type) {\n//       case 'MESSAGE':\n//         setMessages(prev => [...prev, data.data]);\n//         break;\n//       case 'HISTORY':\n//         setMessages(data.data);\n//         break;\n//       case 'AUTH_ERROR':\n//         setError(`Authentication error: ${data.message}`);\n//         localStorage.removeItem('token');\n//         window.location.reload();\n//         break;\n//       default:\n//         console.warn('Unhandled message type:', data.type);\n//     }\n//   }, []);\n\n//   const processMessageQueue = () => {\n//     while (messageQueue.current.length > 0 && socketRef.current?.readyState === WebSocket.OPEN) {\n//       const message = messageQueue.current.shift();\n//       socketRef.current.send(JSON.stringify(message));\n//     }\n//   };\n\n//   // 2. Обновленный useWebSocket.js (React)\n// const connect = useCallback(() => {\n//   const wsUrl = getWebSocketUrl();\n//   if (!wsUrl) return;\n\n//   if (socketRef.current) {\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\n//       console.log('Already connected');\n//       return;\n//     }\n//     socketRef.current.close();\n//   }\n\n//   console.log('Attempting WebSocket connection...');\n//   setConnectionStatus('connecting');\n\n//   const ws = new WebSocket(wsUrl);\n//   socketRef.current = ws;\n\n//   ws.onopen = () => {\n//     console.log('WebSocket connected');\n//     setIsConnected(true);\n//     setConnectionStatus('connected');\n//     setError(null);\n//     reconnectInterval.current = 1000;\n//     processMessageQueue();\n\n//     // Запрос истории\n//     const historyRequest = JSON.stringify({\n//       type: 'GET_HISTORY',\n//       timestamp: Date.now()\n//     });\n//     ws.send(historyRequest);\n//   };\n\n//   ws.onmessage = (event) => {\n//     try {\n//       const parsedData = JSON.parse(event.data);\n//       handleIncomingMessage(parsedData);\n//     } catch (e) {\n//       console.error('Message parse error:', e);\n//     }\n//   };\n\n//   ws.onerror = (error) => {\n//     console.error('WebSocket error:', error);\n//     setError('Connection error');\n//     setConnectionStatus('error');\n//   };\n\n//   ws.onclose = (event) => {\n//     console.log(`WebSocket closed: ${event.code}`, event.reason);\n//     setIsConnected(false);\n//     setConnectionStatus('disconnected');\n\n//     if (event.code === 4002) { // Аутентификация\n//       handleIncomingMessage({\n//         type: 'AUTH_ERROR',\n//         message: event.reason || 'Authentication failed'\n//       });\n//       return;\n//     }\n\n//     if (!event.wasClean && event.code !== 1000) {\n//       const timeout = Math.min(reconnectInterval.current * 2, 30000);\n//       reconnectInterval.current = timeout;\n//       console.log(`Reconnecting in ${timeout}ms...`);\n//       reconnectTimeoutRef.current = setTimeout(connect, timeout);\n//     }\n//   };\n// }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = null;\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     const userId = parseInt(localStorage.getItem('userId'), 10);\n//     if (isNaN(userId)) {\n//       setError('Invalid user ID');\n//       return;\n//     }\n\n//     const fullMessage = {\n//       ...message,\n//       timestamp: Date.now(),\n//       userId,\n//       username: localStorage.getItem('username') || 'unknown'\n//     };\n\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       try {\n//         socketRef.current.send(JSON.stringify(fullMessage));\n//       } catch (e) {\n//         console.error('Send error:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.warn('Queueing message - connection not ready');\n//       messageQueue.current.push(fullMessage);\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//       messageQueue.current = [];\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error\n//   };\n// }\n\n// export default useWebSocket;\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     const token = localStorage.getItem('token');\n//     if (!token) {\n//       setError('Authentication token not found');\n//       return null;\n//     }\n\n//     try {\n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     if (data.type === 'AUTH_ERROR') {\n//       console.error('Authentication error:', data.message);\n//       setError(data.message);\n//       disconnect();\n//       localStorage.removeItem('token');\n//       window.location.reload();\n//       return;\n//     }\n//     setMessages(prev => [...prev, data]);\n//   }, []);\n\n//   const connect = useCallback(() => {\n//     const wsUrl = getWebSocketUrl();\n//     if (!wsUrl) return;\n\n//     if (socketRef.current && \n//       [WebSocket.OPEN, WebSocket.CONNECTING].includes(socketRef.current.readyState)) {\n//       console.warn('WebSocket already connecting or connected');\n//       return;\n//     }\n\n//     setConnectionStatus('connecting');\n//     console.log('Connecting to WebSocket...');\n\n//     socketRef.current = new WebSocket(wsUrl);\n\n//     socketRef.current.onopen = () => {\n//       console.log('WebSocket connected');\n//       setIsConnected(true);\n//       setConnectionStatus('connected');\n//       setError(null);\n//     };\n\n//     socketRef.current.onmessage = (event) => {\n//       try {\n//         const parsedData = JSON.parse(event.data);\n//         handleIncomingMessage(parsedData);\n//       } catch (e) {\n//         console.warn('Non-JSON message:', event.data);\n//         handleIncomingMessage({ content: event.data });\n//       }\n//     };\n\n//     socketRef.current.onerror = (event) => {\n//       console.error('WebSocket error:', event);\n//       setError('WebSocket connection error');\n//       setConnectionStatus('error');\n//     };\n\n//     socketRef.current.onclose = (event) => {\n//       console.log(`WebSocket closed: ${event.code} ${event.reason}`);\n//       setIsConnected(false);\n//       setConnectionStatus('disconnected');\n\n//       if (!event.wasClean && event.code !== 1000) {\n//         console.log('Reconnecting in 3 seconds...');\n//         reconnectTimeoutRef.current = setTimeout(() => {\n//           connect();\n//         }, 3000);\n//       }\n//     };\n//   }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = () => {};\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       const messageWithAuth = {\n//         ...message,\n//         timestamp: new Date().toISOString(),\n//         user_id: parseInt(localStorage.getItem('userId'), 10),\n//         username: localStorage.getItem('username') || 'unknown',\n//       };\n//       const raw = localStorage.getItem('username');\n//       console.log('Stored username:', raw); // должно быть нормальное имя\n\n//       try {\n//         socketRef.current.send(JSON.stringify(messageWithAuth));\n//       } catch (e) {\n//         console.error('Error sending message:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.error('Cannot send message - WebSocket not open');\n//       setError('Connection not ready');\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error,\n//   };\n// }\n\n// export default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useWebSocket","webSocketUrl","apiUrl","token","_s","messages","setMessages","status","setStatus","error","setError","ws","reconnectAttempts","loadHistory","response","fetch","headers","ok","Error","history","json","err","message","console","connectWebSocket","wsUrl","URL","searchParams","set","current","WebSocket","href","onopen","log","onmessage","event","newMessage","JSON","parse","data","prev","onclose","code","reason","timeout","Math","min","setTimeout","onerror","_ws$current","readyState","OPEN","close","sendMessage","_ws$current2","send","stringify","timestamp","Date","toISOString","retry"],"sources":["/Users/darinautalieva/Desktop/GOProject/forum-frontend/src/hooks/useWebSocket.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\n\nconst useWebSocket = (webSocketUrl, apiUrl, token) => {\n  const [messages, setMessages] = useState([]);\n  const [status, setStatus] = useState('disconnected');\n  const [error, setError] = useState(null);\n  const ws = useRef(null);\n  const reconnectAttempts = useRef(0);\n\n  const loadHistory = useCallback(async () => {\n    try {\n      const response = await fetch(apiUrl, {\n        headers: { 'Authorization': `Bearer ${token}` }\n      });\n      \n      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n      \n      const history = await response.json();\n      setMessages(history);\n    } catch (err) {\n      setError(err.message);\n      console.error('History load error:', err);\n    }\n  }, [apiUrl, token]);\n\n  const connectWebSocket = useCallback(() => {\n    if (!token || status === 'connected') return;\n\n    const wsUrl = new URL(webSocketUrl);\n    wsUrl.searchParams.set('token', token);\n\n    ws.current = new WebSocket(wsUrl.href);\n    setStatus('connecting');\n\n    ws.current.onopen = () => {\n      console.log('WebSocket connected');\n      reconnectAttempts.current = 0;\n      setStatus('connected');\n      setError(null);\n    };\n\n    ws.current.onmessage = (event) => {\n      try {\n        const newMessage = JSON.parse(event.data);\n        setMessages(prev => [...prev, newMessage]);\n      } catch (err) {\n        console.error('Message parse error:', err);\n      }\n    };\n\n    ws.current.onclose = (event) => {\n      console.log('WebSocket closed:', event.code, event.reason);\n      setStatus('disconnected');\n      \n      if (event.code === 4001 || event.code === 4002) {\n        setError('Authentication required');\n        return;\n      }\n\n      // Exponential backoff reconnect\n      const timeout = Math.min(1000 * 2 ** reconnectAttempts.current, 30000);\n      setTimeout(() => {\n        reconnectAttempts.current++;\n        connectWebSocket();\n      }, timeout);\n    };\n\n    ws.current.onerror = (err) => {\n      console.error('WebSocket error:', err);\n      setStatus('error');\n      setError('Connection error');\n    };\n  }, [webSocketUrl, token, status]);\n\n  useEffect(() => {\n    if (!token) {\n      setError('Authentication token is required');\n      return;\n    }\n\n    loadHistory();\n    connectWebSocket();\n\n    return () => {\n      if (ws.current?.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [token, loadHistory, connectWebSocket]);\n\n  const sendMessage = useCallback((message) => {\n    if (ws.current?.readyState === WebSocket.OPEN) {\n      ws.current.send(JSON.stringify({\n        ...message,\n        timestamp: new Date().toISOString()\n      }));\n    }\n  }, []);\n\n  return {\n    messages,\n    sendMessage,\n    status,\n    error,\n    retry: loadHistory\n  };\n};\n\nexport default useWebSocket;\n// // useWebSocket.js\n// import { useState, useEffect } from 'react';\n// const useWebSocket = (url) => {\n//     const [socket, setSocket] = useState(null);\n//     const [messages, setMessages] = useState([]);\n//     const [connectionStatus, setConnectionStatus] = useState('disconnected');\n\n//     useEffect(() => {\n//         const ws = new WebSocket(url);\n        \n//         ws.onopen = () => {\n//             console.log('WebSocket connected');\n//             setSocket(ws);\n//             setConnectionStatus('connected');\n//         };\n\n//         ws.onmessage = (event) => {\n//             try {\n//                 const newMessage = JSON.parse(event.data);\n//                 setMessages(prev => [...prev, newMessage]);\n//             } catch (err) {\n//                 console.error('Error parsing WebSocket message:', err);\n//             }\n//         };\n\n//         ws.onclose = () => {\n//             console.log('WebSocket disconnected');\n//             setSocket(null);\n//             setConnectionStatus('disconnected');\n//             // Attempt to reconnect after 5 seconds\n//             setTimeout(() => {\n//                 setConnectionStatus('reconnecting');\n//             }, 5000);\n//         };\n\n//         ws.onerror = (error) => {\n//             console.error('WebSocket error:', error);\n//             setConnectionStatus('error');\n//         };\n\n//         return () => {\n//             if (ws && ws.readyState === WebSocket.OPEN) {\n//                 ws.close();\n//             }\n//         };\n//     }, [url]);\n\n//     const sendMessage = (message) => {\n//         if (socket && socket.readyState === WebSocket.OPEN) {\n//             socket.send(JSON.stringify(message));\n//         } else {\n//             console.error('WebSocket is not connected');\n//             // Optionally queue messages when disconnected\n//         }\n//     };\n\n//     return { \n//         socket, \n//         messages, \n//         sendMessage, \n//         connectionStatus \n//     };\n// };\n\n// export default useWebSocket; // Добавьте эту строку\n\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const reconnectInterval = useRef(1000);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n//   const messageQueue = useRef([]);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     try {\n//       const token = localStorage.getItem('token');\n//       if (!token) {\n//         setError('Authentication token not found');\n//         return null;\n//       }\n      \n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     switch (data.type) {\n//       case 'MESSAGE':\n//         setMessages(prev => [...prev, data.data]);\n//         break;\n//       case 'HISTORY':\n//         setMessages(data.data);\n//         break;\n//       case 'AUTH_ERROR':\n//         setError(`Authentication error: ${data.message}`);\n//         localStorage.removeItem('token');\n//         window.location.reload();\n//         break;\n//       default:\n//         console.warn('Unhandled message type:', data.type);\n//     }\n//   }, []);\n\n//   const processMessageQueue = () => {\n//     while (messageQueue.current.length > 0 && socketRef.current?.readyState === WebSocket.OPEN) {\n//       const message = messageQueue.current.shift();\n//       socketRef.current.send(JSON.stringify(message));\n//     }\n//   };\n\n//   // 2. Обновленный useWebSocket.js (React)\n// const connect = useCallback(() => {\n//   const wsUrl = getWebSocketUrl();\n//   if (!wsUrl) return;\n\n//   if (socketRef.current) {\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\n//       console.log('Already connected');\n//       return;\n//     }\n//     socketRef.current.close();\n//   }\n\n//   console.log('Attempting WebSocket connection...');\n//   setConnectionStatus('connecting');\n  \n//   const ws = new WebSocket(wsUrl);\n//   socketRef.current = ws;\n\n//   ws.onopen = () => {\n//     console.log('WebSocket connected');\n//     setIsConnected(true);\n//     setConnectionStatus('connected');\n//     setError(null);\n//     reconnectInterval.current = 1000;\n//     processMessageQueue();\n    \n//     // Запрос истории\n//     const historyRequest = JSON.stringify({\n//       type: 'GET_HISTORY',\n//       timestamp: Date.now()\n//     });\n//     ws.send(historyRequest);\n//   };\n\n//   ws.onmessage = (event) => {\n//     try {\n//       const parsedData = JSON.parse(event.data);\n//       handleIncomingMessage(parsedData);\n//     } catch (e) {\n//       console.error('Message parse error:', e);\n//     }\n//   };\n\n//   ws.onerror = (error) => {\n//     console.error('WebSocket error:', error);\n//     setError('Connection error');\n//     setConnectionStatus('error');\n//   };\n\n//   ws.onclose = (event) => {\n//     console.log(`WebSocket closed: ${event.code}`, event.reason);\n//     setIsConnected(false);\n//     setConnectionStatus('disconnected');\n\n//     if (event.code === 4002) { // Аутентификация\n//       handleIncomingMessage({\n//         type: 'AUTH_ERROR',\n//         message: event.reason || 'Authentication failed'\n//       });\n//       return;\n//     }\n\n//     if (!event.wasClean && event.code !== 1000) {\n//       const timeout = Math.min(reconnectInterval.current * 2, 30000);\n//       reconnectInterval.current = timeout;\n//       console.log(`Reconnecting in ${timeout}ms...`);\n//       reconnectTimeoutRef.current = setTimeout(connect, timeout);\n//     }\n//   };\n// }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = null;\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     const userId = parseInt(localStorage.getItem('userId'), 10);\n//     if (isNaN(userId)) {\n//       setError('Invalid user ID');\n//       return;\n//     }\n    \n//     const fullMessage = {\n//       ...message,\n//       timestamp: Date.now(),\n//       userId,\n//       username: localStorage.getItem('username') || 'unknown'\n//     };\n\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       try {\n//         socketRef.current.send(JSON.stringify(fullMessage));\n//       } catch (e) {\n//         console.error('Send error:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.warn('Queueing message - connection not ready');\n//       messageQueue.current.push(fullMessage);\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//       messageQueue.current = [];\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error\n//   };\n// }\n\n// export default useWebSocket;\n// import { useEffect, useRef, useState, useCallback } from 'react';\n\n// export function useWebSocket(url, { manual = false } = {}) {\n//   const socketRef = useRef(null);\n//   const reconnectTimeoutRef = useRef(null);\n//   const [isConnected, setIsConnected] = useState(false);\n//   const [connectionStatus, setConnectionStatus] = useState('disconnected');\n//   const [messages, setMessages] = useState([]);\n//   const [error, setError] = useState(null);\n\n//   const getWebSocketUrl = useCallback(() => {\n//     const token = localStorage.getItem('token');\n//     if (!token) {\n//       setError('Authentication token not found');\n//       return null;\n//     }\n\n//     try {\n//       const wsUrl = new URL(url);\n//       wsUrl.searchParams.set('token', token);\n//       return wsUrl.toString();\n//     } catch (e) {\n//       console.error('Invalid WebSocket URL:', e);\n//       setError('Invalid WebSocket URL');\n//       return null;\n//     }\n//   }, [url]);\n\n//   const handleIncomingMessage = useCallback((data) => {\n//     if (data.type === 'AUTH_ERROR') {\n//       console.error('Authentication error:', data.message);\n//       setError(data.message);\n//       disconnect();\n//       localStorage.removeItem('token');\n//       window.location.reload();\n//       return;\n//     }\n//     setMessages(prev => [...prev, data]);\n//   }, []);\n\n//   const connect = useCallback(() => {\n//     const wsUrl = getWebSocketUrl();\n//     if (!wsUrl) return;\n\n//     if (socketRef.current && \n//       [WebSocket.OPEN, WebSocket.CONNECTING].includes(socketRef.current.readyState)) {\n//       console.warn('WebSocket already connecting or connected');\n//       return;\n//     }\n\n//     setConnectionStatus('connecting');\n//     console.log('Connecting to WebSocket...');\n\n//     socketRef.current = new WebSocket(wsUrl);\n\n//     socketRef.current.onopen = () => {\n//       console.log('WebSocket connected');\n//       setIsConnected(true);\n//       setConnectionStatus('connected');\n//       setError(null);\n//     };\n\n//     socketRef.current.onmessage = (event) => {\n//       try {\n//         const parsedData = JSON.parse(event.data);\n//         handleIncomingMessage(parsedData);\n//       } catch (e) {\n//         console.warn('Non-JSON message:', event.data);\n//         handleIncomingMessage({ content: event.data });\n//       }\n//     };\n\n//     socketRef.current.onerror = (event) => {\n//       console.error('WebSocket error:', event);\n//       setError('WebSocket connection error');\n//       setConnectionStatus('error');\n//     };\n\n//     socketRef.current.onclose = (event) => {\n//       console.log(`WebSocket closed: ${event.code} ${event.reason}`);\n//       setIsConnected(false);\n//       setConnectionStatus('disconnected');\n\n//       if (!event.wasClean && event.code !== 1000) {\n//         console.log('Reconnecting in 3 seconds...');\n//         reconnectTimeoutRef.current = setTimeout(() => {\n//           connect();\n//         }, 3000);\n//       }\n//     };\n//   }, [getWebSocketUrl, handleIncomingMessage]);\n\n//   const disconnect = useCallback((permanent = false) => {\n//     if (socketRef.current) {\n//       if (permanent) {\n//         socketRef.current.onclose = () => {};\n//       }\n//       socketRef.current.close(\n//         permanent ? 1000 : 1001,\n//         permanent ? 'Normal closure' : 'Reconnecting'\n//       );\n//     }\n//     if (reconnectTimeoutRef.current) {\n//       clearTimeout(reconnectTimeoutRef.current);\n//     }\n//   }, []);\n\n//   const sendMessage = useCallback((message) => {\n//     if (socketRef.current?.readyState === WebSocket.OPEN) {\n//       const messageWithAuth = {\n//         ...message,\n//         timestamp: new Date().toISOString(),\n//         user_id: parseInt(localStorage.getItem('userId'), 10),\n//         username: localStorage.getItem('username') || 'unknown',\n//       };\n//       const raw = localStorage.getItem('username');\n//       console.log('Stored username:', raw); // должно быть нормальное имя\n      \n//       try {\n//         socketRef.current.send(JSON.stringify(messageWithAuth));\n//       } catch (e) {\n//         console.error('Error sending message:', e);\n//         setError('Failed to send message');\n//       }\n//     } else {\n//       console.error('Cannot send message - WebSocket not open');\n//       setError('Connection not ready');\n//     }\n//   }, []);\n\n//   useEffect(() => {\n//     if (!manual) {\n//       connect();\n//     }\n\n//     return () => {\n//       disconnect(true);\n//     };\n//   }, [connect, disconnect, manual]);\n\n//   return {\n//     isConnected,\n//     connectionStatus,\n//     messages,\n//     sendMessage,\n//     connect,\n//     disconnect,\n//     error,\n//   };\n// }\n\n// export default useWebSocket;"],"mappings":"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;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}