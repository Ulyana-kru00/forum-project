{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState, useCallback } from 'react';\nexport function useWebSocket(url, {\n  manual = false\n} = {}) {\n  _s();\n  const socketRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n  const getWebSocketUrl = useCallback(() => {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      setError('Authentication token not found');\n      return null;\n    }\n    try {\n      const wsUrl = new URL(url);\n      wsUrl.searchParams.set('token', token);\n      return wsUrl.toString();\n    } catch (e) {\n      console.error('Invalid WebSocket URL:', e);\n      setError('Invalid WebSocket URL');\n      return null;\n    }\n  }, [url]);\n  const handleIncomingMessage = useCallback(data => {\n    if (data.type === 'AUTH_ERROR') {\n      console.error('Authentication error:', data.message);\n      setError(data.message);\n      disconnect();\n      localStorage.removeItem('token');\n      window.location.reload();\n      return;\n    }\n    setMessages(prev => [...prev, data]);\n  }, []);\n\n  // useWebSocket.js\n  const connect = useCallback(() => {\n    const wsUrl = getWebSocketUrl();\n    if (!wsUrl) return;\n\n    // Clear previous error\n    setError(null);\n\n    // Add connection timeout\n    const connectionTimeout = setTimeout(() => {\n      if (!isConnected) {\n        setError('Connection timeout');\n        disconnect();\n      }\n    }, 5000);\n    socketRef.current = new WebSocket(wsUrl);\n    socketRef.current.onopen = () => {\n      clearTimeout(connectionTimeout);\n      setIsConnected(true);\n      setConnectionStatus('connected');\n    };\n\n    // Handle close with retries\n    socketRef.current.onclose = event => {\n      clearTimeout(connectionTimeout);\n      setIsConnected(false);\n      setConnectionStatus('disconnected');\n      if (event.code === 1008 || event.code === 4001) {\n        // Permanent error, don't reconnect\n        setError('Authentication expired. Please relogin.');\n      } else if (!event.wasClean) {\n        reconnectTimeoutRef.current = setTimeout(() => {\n          connect();\n        }, 3000);\n      }\n    };\n  }, [getWebSocketUrl, isConnected]);\n  const disconnect = useCallback((permanent = false) => {\n    if (socketRef.current) {\n      if (permanent) {\n        socketRef.current.onclose = () => {};\n      }\n      socketRef.current.close(permanent ? 1000 : 1001, permanent ? 'Normal closure' : 'Reconnecting');\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n  }, []);\n  const sendMessage = useCallback(message => {\n    var _socketRef$current;\n    if (((_socketRef$current = socketRef.current) === null || _socketRef$current === void 0 ? void 0 : _socketRef$current.readyState) === WebSocket.OPEN) {\n      const messageWithAuth = {\n        ...message,\n        timestamp: new Date().toISOString(),\n        user_id: parseInt(localStorage.getItem('userId'), 10),\n        username: localStorage.getItem('username') || 'unknown'\n      };\n      const raw = localStorage.getItem('username');\n      console.log('Stored username:', raw); // должно быть нормальное имя\n\n      try {\n        socketRef.current.send(JSON.stringify(messageWithAuth));\n      } catch (e) {\n        console.error('Error sending message:', e);\n        setError('Failed to send message');\n      }\n    } else {\n      console.error('Cannot send message - WebSocket not open');\n      setError('Connection not ready');\n    }\n  }, []);\n  useEffect(() => {\n    if (!manual) {\n      connect();\n    }\n    return () => {\n      disconnect(true);\n    };\n  }, [connect, disconnect, manual]);\n  return {\n    isConnected,\n    connectionStatus,\n    messages,\n    sendMessage,\n    connect,\n    disconnect,\n    error\n  };\n}\n_s(useWebSocket, \"vPPQoK0jlNnRWGamV6kh/z2+XwI=\");\nexport default useWebSocket;","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useWebSocket","url","manual","_s","socketRef","reconnectTimeoutRef","isConnected","setIsConnected","connectionStatus","setConnectionStatus","messages","setMessages","error","setError","getWebSocketUrl","token","localStorage","getItem","wsUrl","URL","searchParams","set","toString","e","console","handleIncomingMessage","data","type","message","disconnect","removeItem","window","location","reload","prev","connect","connectionTimeout","setTimeout","current","WebSocket","onopen","clearTimeout","onclose","event","code","wasClean","permanent","close","sendMessage","_socketRef$current","readyState","OPEN","messageWithAuth","timestamp","Date","toISOString","user_id","parseInt","username","raw","log","send","JSON","stringify"],"sources":["/Users/darinautalieva/Desktop/GOProject/forum-frontend/src/hooks/useWebSocket.js"],"sourcesContent":["\nimport { useEffect, useRef, useState, useCallback } from 'react';\n\nexport function useWebSocket(url, { manual = false } = {}) {\n  const socketRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const [messages, setMessages] = useState([]);\n  const [error, setError] = useState(null);\n\n  const getWebSocketUrl = useCallback(() => {\n    const token = localStorage.getItem('token');\n    if (!token) {\n      setError('Authentication token not found');\n      return null;\n    }\n\n    try {\n      const wsUrl = new URL(url);\n      wsUrl.searchParams.set('token', token);\n      return wsUrl.toString();\n    } catch (e) {\n      console.error('Invalid WebSocket URL:', e);\n      setError('Invalid WebSocket URL');\n      return null;\n    }\n  }, [url]);\n\n  const handleIncomingMessage = useCallback((data) => {\n    if (data.type === 'AUTH_ERROR') {\n      console.error('Authentication error:', data.message);\n      setError(data.message);\n      disconnect();\n      localStorage.removeItem('token');\n      window.location.reload();\n      return;\n    }\n    setMessages(prev => [...prev, data]);\n  }, []);\n\n  // useWebSocket.js\nconst connect = useCallback(() => {\n  const wsUrl = getWebSocketUrl();\n  if (!wsUrl) return;\n\n  // Clear previous error\n  setError(null);\n\n  // Add connection timeout\n  const connectionTimeout = setTimeout(() => {\n    if (!isConnected) {\n      setError('Connection timeout');\n      disconnect();\n    }\n  }, 5000);\n\n  socketRef.current = new WebSocket(wsUrl);\n\n  socketRef.current.onopen = () => {\n    clearTimeout(connectionTimeout);\n    setIsConnected(true);\n    setConnectionStatus('connected');\n  };\n\n  // Handle close with retries\n  socketRef.current.onclose = (event) => {\n    clearTimeout(connectionTimeout);\n    setIsConnected(false);\n    setConnectionStatus('disconnected');\n\n    if (event.code === 1008 || event.code === 4001) {\n      // Permanent error, don't reconnect\n      setError('Authentication expired. Please relogin.');\n    } else if (!event.wasClean) {\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, 3000);\n    }\n  };\n}, [getWebSocketUrl, isConnected]);\n  const disconnect = useCallback((permanent = false) => {\n    if (socketRef.current) {\n      if (permanent) {\n        socketRef.current.onclose = () => {};\n      }\n      socketRef.current.close(\n        permanent ? 1000 : 1001,\n        permanent ? 'Normal closure' : 'Reconnecting'\n      );\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n  }, []);\n\n  const sendMessage = useCallback((message) => {\n    if (socketRef.current?.readyState === WebSocket.OPEN) {\n      const messageWithAuth = {\n        ...message,\n        timestamp: new Date().toISOString(),\n        user_id: parseInt(localStorage.getItem('userId'), 10),\n        username: localStorage.getItem('username') || 'unknown',\n      };\n      const raw = localStorage.getItem('username');\n      console.log('Stored username:', raw); // должно быть нормальное имя\n      \n      try {\n        socketRef.current.send(JSON.stringify(messageWithAuth));\n      } catch (e) {\n        console.error('Error sending message:', e);\n        setError('Failed to send message');\n      }\n    } else {\n      console.error('Cannot send message - WebSocket not open');\n      setError('Connection not ready');\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!manual) {\n      connect();\n    }\n\n    return () => {\n      disconnect(true);\n    };\n  }, [connect, disconnect, manual]);\n\n  return {\n    isConnected,\n    connectionStatus,\n    messages,\n    sendMessage,\n    connect,\n    disconnect,\n    error,\n  };\n}\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}